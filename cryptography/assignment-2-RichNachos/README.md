სახელი და გვარი: გიორგი კლდიაშვილი  
ფრიუნის იმეილი: gkldi20@freeuni.edu.ge

# მეორე დავალების ინსტრუქცია

ეს დავალება შედგება ორი ნაწილისგან. საწყისი კოდი მოცემულია Python3-ზე. შესაბამისად, უნდა დაწეროთ ამ ენაზე.  

### ამოცანა 1 - ბლოკური კოდის გაშიფვრა (60 ქულა)

საწყისი ფაილები იხილეთ [project_2_1](project_2_1)-ში.

ამ დავალებაში თქვენ უნდა გაშიფროთ შეტყობინება ([ctext.txt](project_2_1/ctext.txt)), რომელიც მიიღეს AES-128-თი CBC-mode-ში [PKCS #7](https://en.wikipedia.org/wiki/Padding_(cryptography)) პადინგით და random IV-ით.
თქვენ გაქვთ წვდომა სერვერთან, რომელიც გაშიფრავს გამოგზავნილ შეტყობინებებს, მაგრამ პასუხად გეტყვით მხოლოდ იმას, მოხდა თუ არა შეცდომა გაშიფრვის დროს 
(1 თუ სწორად გაიშიფრა, 0 თუ არასწორად).
ქსელთან მუშაობის ნაწილი (პაკეტების გაგზავნა და მიღება) იმპლემენტირებულია.

გაშიფრული შეტყობინება (plaintext) ASCII-ში გადაყვანის შემდეგ არის კითხვადი, ასე რომ მარტივად გაიგებთ, სწორია თქვენი ამოხსნა თუ არა.
თქვენი კოდი დაწერეთ ფაილში [decipher.py](project_2_1/decipher.py), რომელიც გაიშვება ბრძანებით
```
python3 decipher.py ctext.txt
```
და stdout-ზე გამოიტანს გაშიფრულ შეტყობინებას (plaintext-ს) პადინგის გარეშე.

#### გატესტვის ინსტრუქცია:  
1) გაუშვით სერვერი ლოკალურად რომელიმე პორტზე, მაგალითად ასე:
```
./server 6667
```
2) `oracle.py` ფაილში ჩაწერეთ ლოკალჰოსტი IP მისამართად და თქვენი არჩეული პორტი, მაგალითად
`s.connect(('127.0.0.1', 6667))`
3) იმის შესამოწმებლად, რომ სერვერი სწორად მუშაობს, გაუშვით ბრძანება
```
python3 sample.py ctext.txt
```
4) საკუთარი კოდის შესამოწმებლად, გაუშვით ბრძანება
```
python3 decipher.py ctext.txt
```

### ამოცანა 2 - CBC-MAC (40 ქულა)

საწყისი ფაილები იხილეთ [project_2_2](project_2_2)-ში.


ამ დავალებაში თქვენ უნდა განახორციელოთ შეტევა raw CBC-MAC-ზე, რითაც აჩვენებთ, რომ ის არ არის დაცული MAC-ი სხვადასხვა სიგრძის შეტყობინებებისთვის.
შეგახსენებთ, როგორ მუშაობს CBC-MAC x-ბლოკიანი შეტყობინებების მაგალითზე:

![CBC-MAC](https://media.cheggcdn.com/media/409/40944253-8cc8-4d0d-90eb-85321a95ad8a/phprlvpCN.png)

თქვენ გაქვთ საშუალება მიიღოთ ტეგები (დაგენერირებული უცნობი გასაღებით) ნებისმიერი 2-ბლოკიანი (32-ბაიტიანი) შეტყობინებისთვის. 
თქვენი ამოცანაა, მიიღოთ ტეგი __ნებისმიერი ლუწი რაოდენობა ბლოკისგან შემდგარი შეტყობინებისთვის__ (შეტყობინების ზომა არ გადააჭარბებს 255 ბაიტს).

თავის შესამოწმებლად, გაქვთ წვდომა სერვერზე არსებულ Verifier-თან, რომელიც გეტყვით, შეესაბამება თუ არა მიღებული ტეგი შეტყობინებას.
როგორც წინა დავალებაში, ქსელთან მუშაობის ნაწილი (პაკეტების გაგზავნა და მიღება) იმპლემენტირებულია.

დასაწყისისთვის, შეგიძლიათ შეამოწმოთ, რომ Mac და Verifier მუშაობენ 2-ბლოკიან [test_message](project_2_2/test_message.txt)-ზე, ხოლო შემდეგ შეამოწმოთ თქვენი ამოხსნა [challenge_message](project_2_2/challenge_message.txt)-ზე: “I, the server, hereby agree that I will pay $100 to this student” (4-ბლოკიანი შეტყობინება). 

თქვენი კოდი დაწერეთ ფაილში [forge.py](project_2_2/forge.py), რომელიც გაიშვება ბრძანებით
```
python3 forge.py challenge_message.txt
```
და stdout-ზე გამოიტანს ტეგს *hex სტრინგად*.

#### გატესტვის ინსტრუქცია:   
1) გაუშვით mac და vrfy სერვერები ლოკალურად რომელიმე პორტებზე, მაგ:
```
./mac-server 6667
```
```
./vrfy-server 6668
```
2) `oracle.py` ფაილში ჩაწერეთ ლოკალჰოსტი IP მისამართად და თქვენი არჩეული პორტები, მაგალითად
`mac_sock.connect(('127.0.0.1', 6667))` <br>
`vrfy_sock.connect(('127.0.0.1', 6668))`

3) იმის შესამოწმებლად, რომ სერვერები სწორად მუშაობს, გაუშვით ბრძანება
```
python3 sample.py test_message.txt
```
4) საკუთარი კოდის შესამოწმებლად, გაუშვით ბრძანება
```
python3 forge.py challenge_message.txt
```
